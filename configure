#! /bin/sh
# ex: sts=8 sw=8 ts=8 noet

: ${CROSS_COMPILER:=}
: ${HOST_CC:=cc}
: ${CC:=${CROSS_COMPILER}cc}

: ${PKGCONFIG:=pkg-config}
: ${WARN_FLAGS_C:="-Wstrict-prototypes -Wmissing-prototypes -Wold-style-definition -Wmissing-declarations -Wbad-function-cast"}
: ${WARN_FLAGS:="-Wall -Wundef -Wshadow -Wcast-align -Wwrite-strings -Wextra -Wno-missing-field-initializers ${WARN_FLAGS_C}"}
: ${GIT_VER:=$(git describe --dirty=+ --always --abbrev=0)}

LIBS=libevdev
# FIXME: libev has bugs in it's headers and as a result requires
# no-strict-aliasing
LIB_CFLAGS="$(${PKGCONFIG} --cflags ${LIBS}) -fno-strict-aliasing -Iccan"
LIB_LDFLAGS="$(${PKGCONFIG} --libs ${LIBS}) -lev"

CFLAGS="${WARN_FLAGS} -std=c99 -D_GNU_SOURCE ${CFLAGS}"
: ${HOST_CFLAGS:=${CFLAGS}}

# Given a series of flags for CC, echo (space seperated) the ones that the
# compiler is happy with.
# XXX: Note that this does mean flags with spaces in them won't work.
cflag_x () {
	local cc=$(eval printf "%s" "\${$1CC}")
	local cflags=$(eval printf "%s" "\${$1CFLAGS:-}")
	shift
	for i in "$@"; do
		$cc $cflags -c -x c "$i" /dev/null -o /dev/null >/dev/null 2>&1 && printf "%s " "$i" || true
	done
}

COMMON_FLAGS="$(cflag_x "" -fsanitize=address -flto -fsanitize=undefined -fvar-tracking-assignments)"
: ${CFLAGS:="${COMMON_FLAGS} -ggdb3 -Os"}

CFLAGS="-DCFG_GIT_VERSION=${GIT_VER} -I. ${LIB_CFLAGS} ${CFLAGS}"

: ${LDFLAGS:="${COMMON_FLAGS}"}
LDFLAGS="${LIB_LDFLAGS} ${LDFLAGS}"

CONFIG_H_GEN=./config_h_gen

CONFIGS=""

exec >build.ninja

cat <<EOF
cc = $CC
objcopy = $OBJCOPY
cflags = $CFLAGS
ldflags = $LDFLAGS

rule cc
  command = \$cc \$cflags -MMD -MF \$out.d  -c \$in -o \$out
  depfile = \$out.d

rule ccld
  command = \$cc \$ldflags -o \$out \$in

rule config_h_frag
  command = ${CONFIG_H_GEN} frag \$in \$cc \$cflags \$ldflags > \$out

rule combine
  command = cat \$in > \$out

rule ninja_gen
  command = $0
  generator = yes
EOF

CONFIGURE_DEPS="$0"

to_out () {
  for i in "$@"; do
    printf "%s " ".build-$out/$i"
  done
}

to_obj () {
  for i in "$@"; do
    printf "%s " ".build-$out/$i.o"
  done
}

_ev () {
	eval echo "\${$1}"
}

config () {
	local configs=""
	for i in config_h/*.c; do
		local name=".config.h-$(${CONFIG_H_GEN} name "$i")-frag"
		echo "build $name : config_h_frag $i | ./if_compiles"
		configs="$configs $name"
	done

	echo "build config.h : combine config_h/prefix.h $configs config_h/suffix.h"
}
# If any files in config_h change, we need to re-generate build.ninja
CONFIGURE_DEPS="$CONFIGURE_DEPS config_h/ ${CONFIG_H_GEN}"

bin () {
	out="$1"
	shift
	out_var="${out/./_}"

	for s in "$@"; do
		echo "build $(to_obj "$s"): cc $s | config.h"
		echo "  cflags = \$cflags -I.build-$out"
	done

	cat <<EOF
build $out : ccld $(to_obj "$@")
EOF
	BINS="$BINS $out"
}
BINS=""

config
bin illum-d   main-daemon.c ccan/ccan/pr_log/pr_log.c
bin illum-ctl main-ctl.c

echo build build.ninja : ninja_gen $CONFIGURE_DEPS
echo default ${BINS}
